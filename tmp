CollisionPoints c;
		if (!a || !b) {return c;}
		if (a->points.size())
		{
			std::vector<geometry::Line> lines;
			for (auto pt = a->points.begin() + 1; pt != a->points.end(); pt++)
			{
				lines.push_back(geometry::Line(geometry::Vector(ta.position + *(pt - 1) + a->pos),
					geometry::Vector(ta.position + *pt + a->pos)));
			}
			geometry::Line deepest;
			bool reached = false;
			for (const geometry::Line& l: lines)	
			{
				if (geometry::Calc::Distance(l, b->center + tb.position) <= b->radius)
				{
					if (!reached)
					{
						deepest = l;
						reached = true;
					}
					if (geometry::Calc::Distance(l, b->center + tb.position) <
							geometry::Calc::Distance(deepest, b->center + tb.position))
					{
						deepest = l;
					}
				}
			}
			if (!reached) {return c;}
			c.b = deepest.a;
			c.a = deepest.b;
			/*c.b = geometry::Calc::GetVectorOnCircle(b->center + tb.position, b->radius, fmod(deepest.angle() + M_PI / 2, M_PI * 2));
			geometry::Line circLine;
			circLine.a = b->center + tb.position;
			circLine.b = c.b;
			c.a = geometry::Calc::VectorOfIntersect(circLine, deepest, false);
			*/c.depth = geometry::Calc::Distance(c.a, c.b);
			c.normal = c.b - c.a;
			c.normal.Normalize();
			c.hasCollision = true;
			return c;
		}
		return c;

		std::vector<geometry::Vector> normals;
		for (unsigned i = 0; i < a->points.size(); i++)
		{
			unsigned long i2 = i + 1 < a->points.size() ? i + 1 : 0;
			geometry::Vector face = a->points[i2] - a->points[i];
			normals.push_back(geometry::Vector(face.y, -face.x));
			normals[i].Normalize();
		}
		geometry::Vector center = b->center + tb.position;
		center = ta.rotation.Transpose() * (center - (a->pos + ta.position));
		f64 separation = std::numeric_limits<double>::min();
		unsigned long faceNormal = 0;
		for (unsigned long i = 0; i < a->points.size(); i++)
		{
			f64 s = normals.at(i).Dot(center - a->points.at(i));
			if (s > b->radius)
				return c;
			if (s > separation)
			{
				separation = s;
				faceNormal = i;
			}
		}
		geometry::Vector v1 = a->points[faceNormal];
		unsigned long i2 = faceNormal + 1 < a->points.size() ? faceNormal + 1 : 0;
		geometry::Vector v2 = a->points[i2];
		if (separation < 0.0001)
		{
			c.normal = -(ta.rotation * normals[faceNormal]);
			c.hasCollision = true;
			return c;
		}
		f64 dot1 = (center - v1).Dot(v2 - v1);
		f64 dot2 = (center - v1).Dot(v1 - v2);
		if (dot1 <= 0)
		{
			if (pow(geometry::Calc::Distance(center, v1), 2) > b->radius * b->radius)
				return c;
			geometry::Vector n = v1 - center;
			n = ta.rotation * n;
			c.normal = n.Normalized();
			v1 = ta.rotation * v1 + ta.position + a->pos;
			c.a = v1;
			return c;
		}
		else if (dot2 <= 0)
		{
			if (pow(geometry::Calc::Distance(center, v2), 2) > b->radius * b->radius)
				return c;
			geometry::Vector n = v2 - center;
			v2 = ta.rotation * v2 + ta.position + a->pos;
			c.a = v2;
			n = ta.rotation * n;
			n.Normalize();
			c.normal = n;
			return c;
		}
		else
		{
			geometry::Vector n = normals[faceNormal];
			if ((center - v2).Dot(n) > b->radius)
				return c;
			n = ta.rotation * n;
			c.normal = -n;
			c.a = c.normal * b->radius + b->center + tb.position;
			return c;
		}